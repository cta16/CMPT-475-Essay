{\rtf1\ansi\ansicpg1252\deff0\deftab709{\fonttbl{\f0\fnil\fcharset0 Arial;}}
{\colortbl ;\red0\green0\blue0;\red0\green0\blue255;\red0\green0\blue128;}
{\stylesheet{ Normal;}{\s1 heading 1;}{\s2 heading 2;}}
{\*\generator Msftedit 5.41.21.2509;}\viewkind4\uc1\pard\keep\keepn\s2\sb200\sl276\slmult1\cf1\lang4105\b\fs36 Extreme Programming\par
\pard\fi360\sa200\sl276\slmult1\cf0\fs24 CMPT 475 Spring 2012\par
\b0\par
Christopher Tse    |    cta16@sfu.ca    |    556001847\par
\fs36\par
\fs96\par
\b\fs72 FILL IN YOUR INFO\fs96\par
\b0\fs22\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\pard\sl480\slmult1\lang1033\fs24\par
\par
\par
\par
\par
\par
1. Introduction\par
\tab Extreme Programming is a relatively new software development methodology focused on producing software that can be quickly tested and that is as complete as possible at every step, rather than just at the end of the project. It emphasizes teamwork between the developers and the client, and adaptation to client feedback on the project[3]. \par
\tab Unlike in the waterfall method of software development, Extreme programming sets out the initial requirements very loosely. Scheduling of development is done on a regular basis, rather than all at the start, and the features to be developed are determined based on current priorities and customer feedback, rather than the initial plan. This allows for the flexibility to handle unexpected changes to customer requirements, or to manage misinterpretations of the requirements as initially laid out before the product has shipped.\par
\par
2. Practices \par
\tab There are many simple rules and practices that make up Extreme Programming. This essay will only cover a handful of them. They are what makes Extreme Programming, and as such should be followed by teams who want to develop in this methodology. \par
\par
2.1 User Stories & User Acceptance Tests\par
\pard\fi720\sl480\slmult1\qj In XP, requirements elicitation is done entirely though user stories.  In contrast to other methods of requirements engineering, user stories allow the customer and programmer to overcome problems with understanding.   When a customer \ldblquote tells a story about how the system will be used\rdblquote  ([5], pg. 16), the requirements contain more background context allowing the programmers to understand the problem better.  This allows programmers to ask more effective questions about the system to be developed to gain more insight into the problem.  After the exchange of stories and questions the customer may feel that the initial story he or she started with is not satisfactory and will revise it.  The continued revision of the story brings initially hidden requirements into light.\par
\pard\sl480\slmult1\qj\tab If a story is too large it is split up into smaller segments because programmers have more accurate estimates for smaller problems.  As recommended by one of the founders of XP, Ron Jeffries states in his book: \ldblquote stories should encompass a week or two of programmer time\rdblquote  ([5], pg. 18).  For planning purposes this helps the development team stay as close to their estimated schedule as possible.\par
\pard\sl480\slmult1\tab After the implementation is complete, acceptance tests are performed to verify the system indeed satisfies the system described in the user story.  Like other development models, the purpose of acceptance tests remain the same \endash  to allow the customer to verify the system performs as desired and to raise confidence in all the project stakeholders.  However, acceptance tests also have another crucial role unique to XP.  The XP model reduces the amount of documentation necessary by working in reverse; rather than writing the documentation first and deriving test cases from it, XP instead uses the test cases to derive what documentation is necessary.  This model allows programmers to begin developing a system prior to heavy paperwork, and at the final stage only the relevant documentation will surface.  Being agile in nature, XP demands that all tests \endash  acceptance and unit tests \endash  are automated.\par
\par
\pard\sl480\slmult1\qj 2.1.1 Analysis\par
\pard\sl480\slmult1\tab The method of using user stories is an interesting approach.  On first impression it seems the developers may receive unnecessary information.  More traditional software approaches required the customer to only specify what the system must do, and programmers were free to implement it with any desired strategy.  Asking someone to \ldblquote make this for me, and I don\rquote t care how you do it\rdblquote  makes sense as we normally would not expect the client to have much understanding on the technical aspects of development, and those decisions would be better left for the developer to deal with.  Although user stories take more commitment by both parties \endash  customer and developer \endash  due to the amount of communication that must be maintained, the process of writing and revising stories helps the customer understand the product truly desired and helps expose details that may have initially been omitted.  By the same token, when a user story explains in detail the what, where, why, who, and how, it allows the developers to make more informed decisions during the implementation stage.\par
\tab  The role of user acceptance tests strongly enforces the paradigm of XP \endash  a model that is adaptive rather than predictive.  In waterfall models, development parties invest too many resources in analyzing the system and the runtime environments to discover all potential roadblocks.  It is difficult or near impossible to tabulate every possible constraint, and there are likely to be constraints that are irrelevant to the current iteration of the system.  By using acceptance tests at each stage to uncover the requirements, only currently relevant documentation is kept.  This level of abstraction also allows the development team to focus on the current user story at hand, and this leads to a cohesive development system.\par
\pard\fi720\sl480\slmult1\qj XP has a heavy focus on testing, demanding all tests be automated and running them on the system frequently.  Due to XP\rquote s nature in welcoming change, it is important to have lower level modules performing at the highest quality.  This allows higher level models to be switched with another when requirements change, and developers will have confidence that the lower level system will continue to maintain its stability.  That is not to say lower level modules need not be tested when the system as a whole undergoes change (take Ariadne 5 for example).  But as software engineers, we generally do not \ldblquote reinvent the wheel\rdblquote , and we always use previously developed modules as a basis.  For example, when we develop in a programming language, pinpointing the location of an error becomes easier when we can trust our compiler, because we know the error is within our own code rather than underlying systems.  This optimism may not be applicable to large scale projects because of the amount of coupling necessary resulting in a more complex system, but XP is not an effective methodology when the project size is large due to face to face communication losing effectiveness.\par
\pard\sl480\slmult1\par
2.2 Iterative Development\par
\tab A core component of Extreme Programming is iterative development. Instead of development being scheduled across an entire release plan, it is scheduled into 1-3 week iterations, which are organized immediately before being worked on. It allows for unforeseen feature requests or requirements issues to be handled when they come up, rather than waiting until the end of the project, or requiring clairvoyant planning teams.\par
\tab The structure of an iteration is fairly simple. Take the highest priority features than can be done in the iteration length \u9472? usually one week, but could be as long as three \u9472? and put them together as the iteration plan. These features are exclusively what will be done in the next iteration. If the features needed to be done seem to be taking too long, re-plan in the middle of the iteration to determine which features can be pushed back. Once the iteration is done, the current version of the product should be tested with the customer, to ensure that the project remains on track. \par
\tab It is crucial that the iteration be taken as a hard deadline. While extreme programming is much more conducive to floating deadlines for the entire project, the iterations need to stay on track.\par
\par
2.2.1 Analysis \par
\tab The primary benefit to iterative development is that the project is being continuously revised to respond and adapt to the customer's needs. There is less concern about requirements as well, as these can be reviewed more easily once parts of the system are in place and thus there is a more concrete perspective on the system. \par
\tab An element that is somewhat ambiguous is that iterations are the level at which flexibility and adaptability essentially stop. This is good because it provides structure to the project, but may be problematic if the time per iteration is too large to adapt effectively, or too small to allow for the long-term planning of a project to be useful, such as in a large team or with a military or government project, where the requirements may not be as likely to change with use. How this affects development varies greatly from project to project, and is a key aspect of extreme programming that needs to be carefully considered during the initial project planning, when determining the development methodology.\par
\tab The downside to iterative development is that it can be short-sighted. While this can be mitigated for really large features by breaking them down, or simply making them be built across iterations, this may not always work. Depending on how set in stone the requirements are, constant revisions and changes may cause large or complex features to be put off continuously. It is important to ensure that features are being added to iterations based on priority as well as feasibility within the time frame.\par
\par
2.3 Iteration Planning\par
\tab A critical practice of XP is frequent iteration, and planning for each iteration as a more solid unit than the plan for the whole release. This is the point where the flexibility of XP goes away and the plan becomes set. While there are times where features can end up rolling over to the next iteration, the iteration end date is meant to be a hard deadline.\par
\tab For planning the release, there should be enough features chosen for the iteration such that the features can be completed in the time given, provided that nothing goes wrong. This should be determined by figuring out how many days it would take to do the feature if there were no distractions, referred to as ideal programming days. If it takes less than 1 day, group them together. If it takes more than 3 days, break them apart. Once you have a good idea how long each feature will take, then the whole iteration can be evaluated. At this stage, if there are too many features, put off some of the lower priority ones until the following iteration. If those that exist would likely be completed within the time of the iteration with time to spare, then add more features to the iteration. \par
\tab When planning iterations, it is also very important to take a look back and see how many features actually got completed during the previous iteration, and use that to determine how quickly features can realistically be completed, and thus how many features should be on the next iteration. It is worth keeping track of how much time was taken to build a feature compared to how much time was estimated, and also how much time was taken up by bug fixes. Bug fixing time is less predictable, and doesn't fit into the idea of the ideal programming day. However, if a feature took longer because its completion time was poorly estimated, then that is something which needs to be considered more carefully going forward. It takes several iterations before it is possible to have an accurate estimate of how quickly features can be completed, and thus how many features can be put into a single iteration. So long as there is a critical eye to the amount of time features take, then the time taken to accurately measure how quickly work can be done is minimized.\par
\par
\lang4105 2.4 Open work spaces\par
\pard\fi360\sa200\sl480\slmult1 Communication is the most important aspect in any team.  Teams often consist of many unique individuals with different levels of experience and different strengths. If teammates do not communicate, then they cannot utilize the full potential of the team. Open Work Spaces addresses the problem by creating an environment where everyone is comfortable to communicate in [1].\par
An example of an Open Work Space is the Japan Airlines office. The CEO of JAL sits at a desk that is on the same floor as many other employees without any walls surrounding him. Many of his employees share desks and don\rquote t have a wall dividing them. By working in the same environment, the gap between different levels and management are not as apparent [1]. This allows employees from all levels to comfortably communicate. Other examples of Open Work Spaces include offices of Facebook and Google. \par
 Different people have different preferences in the way they communicate.  In order to encourage communication even further, Open Work Spaces allows many forms of communications. The various forms may include white boards, sticky notes, charts, and other forms of communication [1]. By providing different ways in which teammates can communicate, all teammates can contribute in a way that they are comfortable with [1].  For example, if a teammate is not comfortable talking in a large group, they can use sticky notes to add to any ideas. Work stations can also be individual or in a cluster to allow teammates to choose how they want to work without excluding themselves from the team [1].\par
\tab Open Work Spaces works in conjunction with other XP components such as Standing Meetings and Pair Programming. The Open Work Space allows everyone to participate in meetings wherever they are in the office. In addition, the location of the Standing Meeting will create a centralized location where everyone can discuss ideas. Open Work Spaces also optimizes Pair Programming because it allows different groups of Pair Programmers to participate in other Pair Programming discussions [9].\par
Although Open Work Spaces has many advantages, it is also important to address potential issues that will make the team ineffective. One of these concerns is Privacy[9]. Without privacy, some team members may feel that they cannot work comfortably[9]. However, the lack of privacy will encourage the interaction between team members and remove the idea that a certain team member \lquote owns\rquote  a certain part of the project. Distractions are another issue that might affect the performance of the teammates[9]. When many groups are discussing strategies, it may be difficult for team members to concentrate. However, studies have shown that team members will adapt to this by automatically filtering out any unnecessary discussions[9].\par
\pard\sa200\sl480\slmult1\lang1033 2.5 Standing meetings\par
\pard\sl480\slmult1\tab An important component of any XP project is starting the day with a standing meeting. These need to be conducted in a fairly central location, and should be short. The point is to keep everyone up to date on what everyone is doing, and to point out any issues that may need discussion after the standup meeting. \par
\tab The structure for these meetings is to go around to each of the developers, and have them talk briefly about what they did yesterday, what they plan to do today, and what obstacles they are having in completing their job. This allows other developers to understand where the team is at. It also gives opportunities to bring up quick fixes to small issues, or let someone know if they are a bottleneck on part of the project, so they can re-prioritize appropriately. It is important that these discussions are kept brief. If they require more 1-on-1 or small group discussion they should be done after the stand-up meeting is over. \par
\tab It is important that these meetings are conducted regularly. If they are not then it is easy for the developers to lose a clear picture of what everyone else is working on, and thus makes future communication with team members more difficult. It also means that more meetings are needed between small groups which can eat more time than necessary if there was the stand-up meeting in the morning. The time constraint on the stand-up meeting encourages quick action and no time wasted, while meetings in smaller groups can get sidetracked by certain ideas or discussions, as they aren't necessarily as constrained.\par
\tab Another important but non-critical part of stand-up meetings is a whiteboard. With a whiteboard that has the schedule for the team for the iteration cycle, there is a reference point for the activities the developers are doing. When they bring up their activity the previous day and their plans for the day, they can be compared with the whiteboard schedule, which can either cause the developer to change their priorities, or cause the whiteboard schedule to change in response to their activities, which may have been critical bug fixes or simply an increase in the amount of time it is taking to build the feature they are currently working on.\par
\par
2.5.1 Analysis\par
\tab The main benefit to stand-up meetings is synchronization with the team. Knowing where everyone else is in the project is good both for knowing how well the scheduling is working for the iteration, and for morale. Constant reassurance that everyone on the team is doing their job, and that they are willing to help with any obstacles that might come up for development, is a great way to keep a team together and motivated. It also ensures that any problems which come up will be resolved by the next morning at the latest.\par
\pard\sa200\sl480\slmult1\lang9\tab The downside to stand-up meetings is that they do take some time, and require some discipline in remembering to do them and in keeping track of what work has been done. This isn't a major con, it just means you can't be lazy.\par
\pard\sl480\slmult1\lang1033\par
2.6 Simplicity \par
\tab Software development has a phrase called \ldblquote Keep It Simple Stupid\rdblquote  (KISS), it helps others with understanding your code and would generally make the overall program more maintainable. XP takes this a step further and includes it as a functional requirement instead of a guideline. Simple functions are easier to maintain, create, and modify.\par
\tab Accompanying the new importance of simplicity are four subjective qualities: \ldblquote Testable, Understandable, Browsable, and Explainable (TUBE)\rdblquote .[2]. The qualities are familiar but are now more important in XP.\par
\tab Testing is a fundamental part of any software design. It is made to ensure quality and proper functionality in a product. So with every simple function being written a corresponding acceptance and unit test must be done. This will help with quick feedback and design changes if necessary.\par
\tab Browsable is a somewhat newer concept, but can be summed up with naming conventions. To make a developer\rquote s life easier it is always good to find useful labels for functions, classes, and variables such that it would help with documentation and ease of use. This also helps with inheritance. For example, if you have a base class person and you want to branch off into employees, managers, and other types it would be easily understood by other coders looking at your work.\par
\tab Understandable and explainable can be grouped up together. Understandability will come with time spent on a project, whereas the more important focus is the ability to explain the project ideas. For example if a person recently joined the team and has no idea what is going on. It would help if your functions and methods are easily communicated to the confused individual.\par
\tab To keep things simple and easier to explain it helps to only program functions and methods only when you need them. XP tells us to refrain from creating complex methods that achieve multiple goals. Focus on writing one method for one goal and making it understandable.\par
\par
\lang4105 2.7 Pair Programming\par
\pard\fi720\sa200\sl480\slmult1 Pair Programming is an essential part of XP. A team of programmers can use Pair Programming by pairing up programmers of various skill levels. Both programmers share one computer[8]. While one programmer codes, the other looks over the code for any errors as well as conceptualizing the general form of the solution[6]. The programmers should also discuss their strategy at all times to ensure that they both understand the problem specification and their own solution[6]. The two programmers can switch roles at any time.\par
\pard\sa200\sl480\slmult1\tab The first advantage of Pair Programming is the increased productivity of the programmers and the improved quality of the product[6]. Pair programming can improve productivity in three ways. The programmers become more efficient because they waste less time[6]. Instead of surfing the internet or checking their email, they are motivated to work. If one person is stuck on a problem, both programmers can discuss possible solutions or switch roles. This ensures that both programmers are doing something constructive.  Also, since one programmer is continuously reviewing the code, there is a greater chance that a bug will be discovered and fixed[6]. This will reduce the amount of time spend testing and finding the bug. Lastly, there is a lower number of fragmented code that needs to be merged between groups. \par
\tab Another advantage of Pair programming is that both programmers become better programmers after each session[6]. Every programmer is different in skill level and use different methods to solve the same problem. When programmers discuss with other programmers their strategies, they can discover the disadvantages or advantages of solving the problem in another way.  By discussing the problems, each programmer can also get a better understanding of the problem and how well their solution solves the problem.  Pair programming works well with Open Work Spaces because it allows Pair Programming groups to overhear discussions from other groups[4]. This encourages communication between groups. The result is a more cohesive team and software[4]. \par
\pard\sl480\slmult1\tab Some programmers are more experienced than others. It is easy to see how the less experienced programmer will benefit from this form of programming because the programmer with more experience can spot mistakes made by the other programmer. However, the programmer with more experience can also benefit from this form of programming because they can get a fresh perspective on a problem that they had never considered[6].  \par
\lang1033\par
2.8 Frequent Integration:\par
\pard\fi720\sl480\slmult1 For ease of integration, developers (in pairs) during the construction phase must get in the habit of submitting code to the repository as frequent as possible. This will ensure that there will be little fragmentation in the development process and minimal code diversion. If this is not done often the inconsistencies would cause a significant increase in time spent integrating when large sections of code and functionality are added.\par
\pard\sl480\slmult1 Frequent integration helps identify potential conflicts earlier so that projects can be quickly redesigned and adapt to the new needs of the application. Though this may sound tedious it may prove more convenient than to try and integrate weeks of separate functions together causing fragmentation of versions and potential requirement changes done by other team of developers.\par
\tab Frequent integration is highly encouraged and a fundamental part of keeping fragmentation to a minimum. It is still good to note that a single pair of coders should be integrating their code with the full project repository per few hours of coding. Ensuring that different pairs of developers submit code at different times will prevent conflicting code testing. During the stand-up meeting there should be some discussion of estimated completion of parts of code for integration. Having a good idea of when new code is about to be integrated will help ensure future commits of code will be current and up to date.\tab  \par
\tab With the constant updates it will also be easier to gauge how far the progress of the overall project is going. The iterative nature of the integration would help with efficiency of the overall project development. The users will have tested code more frequently and there would be less integration fixes causing delays in the development of other teams of developers. Frequent integration also promotes communication with other pairs of developers so the entire team can make some assumptions to what is to be expected during integration.\par
\tab Though the idea of frequent integration is simple, it requires a lot of discipline and communication to accomplish. This approach for programming would most likely thrive in small project environment involving few pairs of developers. If this was applied to a larger project involving more people, it could be hard to set times for integration due to the sheer increase in commits.\par
\par
3. Conclusion\par
\tab Extreme Programming allows for much adaptation and review of a project before it is shipped to the customer. It can easily cut costs, improve customer satisfaction, and keep a team going strong through a project [3]. It does require some work and discipline, the cooperation of the client, and the right team. It may not be the best methodology for every project either, but when it can be used, it should be.\par
\par
4. Bibliography\par
[1]\tab Extreme Programming on Space; \lang255{\field{\*\fldinst{HYPERLINK "http://www.extremeprogramming.org/rules/space.html"}}{\fldrslt{\ul\cf2 http://www.extremeprogramming.org/rules/space.html}}}\lang1033\f0\fs24\par
[2]\tab Extreme Programming on Simplicity; \lang255{\field{\*\fldinst{HYPERLINK "http://www.extremeprogramming.org/rules/simple.html"}}{\fldrslt{\ul\cf2 http://www.extremeprogramming.org/rules/simple.html}}}\cf3\ul\f0\fs24   3\cf0\lang1033\ulnone\up10 rd\up0  paragraph.\par
[3] \tab\lang255{\field{\*\fldinst{HYPERLINK "http://www.extremeprogramming.org/"}}{\fldrslt{\ul\cf2 http://www.extremeprogramming.org/}}}\cf3\ul\f0\fs24    2\cf0\lang1033\ulnone\up10 nd\up0  and 3\up10 rd\up0  paragraph\par
\pard\sl480\slmult1\qj [4] \tab\lang255{\field{\*\fldinst{HYPERLINK "http://www.agilemodeling.com/essays/agileModelingXP.htm"}}{\fldrslt{\ul\cf2 http://www.agilemodeling.com/essays/agileModelingXP.htm}}}\lang1033\f0\fs24\par
[5] \tab Extreme Programming Installed (By Ron Jeffries, Ann Anderson, Chet Hendrickson; October 16, 2000)\par
\pard\sa200\sl480\slmult1\lang4105 [6] \tab All I Really Needed to Know about Pair Programming I learned in Kindergarten; {\field{\*\fldinst{HYPERLINK "http://www2.yk.psu.edu/~sg3/cmpbd205/assign/week01/ACMarticlePairProgramming.pdf"}}{\fldrslt{\ul\cf2 http://www2.yk.psu.edu/~sg3/cmpbd205/assign/week01/ACMarticlePairProgramming.pdf}}}\f0\fs24\par
[7]\tab The Art of Agile; {\field{\*\fldinst{HYPERLINK "http://jamesshore.com/Agile-Book/pair_programming.html"}}{\fldrslt{\ul\cf2 http://jamesshore.com/Agile-Book/pair_programming.html}}}\f0\fs24\par
\pard\sl480\slmult1\qj [8] \tab Pair Programming; {\field{\*\fldinst{HYPERLINK "http://www.extremeprogramming.org/rules/pair.html"}}{\fldrslt{\ul\cf2 http://www.extremeprogramming.org/rules/pair.html}}}\lang1033\f0\fs24\par
\lang4105 [9]\tab Working Together in \ldblquote War Rooms\rdblquote  Doubles Teams\rquote  Productivity; {\field{\*\fldinst{HYPERLINK "www.sciencedaily.com/releases/2000/12/001206144705.htm"}}{\fldrslt{\ul\cf2 www.sciencedaily.com/releases/2000/12/001206144705.htm}}}\lang1033\f0\fs24\par
}
 